
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from azure.ai.ml import MLClient
from azure.ai.ml.entities import Data
from azure.ai.ml.constants import AssetTypes
from azure.identity import DefaultAzureCredential
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error, r2_score

from sklearn.model_selection import train_test_split
sns.set(style="whitegrid")


# connect to workspace

ml_client = MLClient(
    DefaultAzureCredential(),
    subscription_id="66e78dfa-39d7-4e77-8ba2-5fae75b2e0d1",
    resource_group_name="nlp-capstone1",
    workspace_name="NLP-Capstone-1"
)

# register the file as a data asset (one-time setup)

data_asset = Data(
    path="azureml://datastores/workspaceblobstore/paths/UI/2025-08-17_062627_UTC/GlobalTempAnomalies.csv",
    type=AssetTypes.URI_FILE,
    name="global-temp-anomalies",
    description="Monthly global temperature anomalies from 1900 to 2023"
)

ml_client.data.create_or_update(data_asset)

# retrieve the asset with version specified

asset = ml_client.data.get(name="global-temp-anomalies", version="1")

# get the remote path to the file

remote_path = asset.path

# load directly from blobstore path

df = pd.read_csv(remote_path, header=None)


# Convert first column to datetime format and set as index
df[df.columns[0]] = pd.to_datetime(df[df.columns[0]])
df.set_index(df.columns[0], inplace=True)

# Rename anomaly columns for clarity
df.columns = [f'ensemble_{i}' for i in range(df.shape[1])]

# Fill missing values in numeric columns
numeric_cols = df.select_dtypes(include=[np.number]).columns
df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].mean())

# Create median anomaly across all ensemble sources
df['Median_Anomaly'] = df[numeric_cols].median(axis=1)

# Smooth anomalies using 12-month rolling average
df['Rolling_Avg'] = df['Median_Anomaly'].rolling(window=12, min_periods=1).mean()

# Calculate year-over-year change (12-month difference)
df['YoY_Change'] = df['Rolling_Avg'].diff(12)

# Drop rows with missing values in rolling average and YoY change
df.dropna(subset=['Rolling_Avg', 'YoY_Change'], inplace=True)

# Create single time series for modeling
df_single = df[['Rolling_Avg', 'YoY_Change']].copy()
df_single['Lag_1'] = df_single['YoY_Change'].shift(1)
df_single['Lag_2'] = df_single['YoY_Change'].shift(2)
df_single['Lag_12'] = df_single['YoY_Change'].shift(12)
df_single['Rolling_Std'] = df_single['YoY_Change'].rolling(window=12, min_periods=1).std()
df_single['Trend'] = np.arange(len(df_single))

# Drop rows with missing values in new features
df_single.dropna(subset=['Lag_1', 'Lag_2', 'Lag_12', 'Rolling_Std'], inplace=True)

# Define feature matrix X and target vector y
X = df_single[['Rolling_Avg', 'Lag_1', 'Lag_2', 'Lag_12', 'Rolling_Std', 'Trend']]
y = df_single['YoY_Change']

# Align X and y lengths
min_len = min(len(X), len(y))
X = X[:min_len]
y = y[:min_len]

# Train-test split (80/20)
split_index = int(len(X) * 0.8)
X_train, X_test = X.iloc[:split_index], X.iloc[split_index:]
y_train, y_test = y.iloc[:split_index], y.iloc[split_index:]




# EDA - Sample 5 ensemble columns for pairplot

sample_cols = df.columns[:100]  # Ensemble columns only
subset = df[sample_cols].sample(axis=1, n=5, random_state=42)
sns.set(style="whitegrid")
sns.pairplot(subset)
plt.show()



# Climate Trends

plt.plot(df.index, df['Median_Anomaly'], label='Median Anomaly')
plt.title('Global Temperature Anomalies (1900–2023)')
plt.xlabel('Year')
plt.ylabel('Temperature Anomaly (°C)')
plt.legend()
plt.show()


# --- Train and evaluate models ---
lr_model = LinearRegression()
lr_model.fit(X_train, y_train)
lr_pred = lr_model.predict(X_test)
lr_r2 = r2_score(y_test, lr_pred)
lr_mse = mean_squared_error(y_test, lr_pred)

dt_model = DecisionTreeRegressor(random_state=42)
dt_model.fit(X_train, y_train)
dt_pred = dt_model.predict(X_test)
dt_r2 = r2_score(y_test, dt_pred)
dt_mse = mean_squared_error(y_test, dt_pred)

# --- Output model performance ---
print(f"Linear Regression R²: {lr_r2:.2f}, MSE: {lr_mse:.4f}")
print(f"Decision Tree R²: {dt_r2:.2f}, MSE: {dt_mse:.4f}")

# --- Choose the model you want to evaluate further ---
# You can switch between lr_pred and dt_pred here
y_pred = lr_pred  # or dt_pred

# --- Calculate residuals ---
residuals = y_test - y_pred

# --- Plot residual distribution ---
import seaborn as sns
sns.histplot(residuals, kde=True, color='purple')
plt.title("Residual Distribution (Smoothed Anomalies)")
plt.xlabel("Residuals")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()



# --- Store models in a dictionary for easy access ---
models = {
    "Linear Regression": lr_model,
    "Decision Tree": dt_model
}

# --- Plot predictions from both models ---
plt.figure(figsize=(12, 6))
plt.plot(y_test.index, y_test, label="Actual (Smoothed)", color='black', linewidth=2)
plt.plot(y_test.index, models["Linear Regression"].predict(X_test), label="Linear Regression", color='blue', linestyle='--')
plt.plot(y_test.index, models["Decision Tree"].predict(X_test), label="Decision Tree", color='orange', linestyle=':')
plt.title("Actual vs Predicted Temperature Anomalies (Smoothed)")
plt.xlabel("Year")
plt.ylabel("Anomaly (°C)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()




df_single = df_single.copy()
# --- Use cleaned single time series ---
df_plot = df_single.copy()

# Step 1: Compute month-over-month change
df_plot['MoM_Change'] = df_plot['Rolling_Avg'].diff()
df_plot['AbsChange'] = df_plot['MoM_Change'].abs()

# Step 2: Sort entire dataset by absolute change
sorted_events = df_plot.sort_values(by='AbsChange', ascending=False)

# Step 3: Select top 10 distinct events with minimum 1-month spacing
distinct_dates = []
for date in sorted_events.index:
    if all(abs((date - d).days) > 30 for d in distinct_dates):
        distinct_dates.append(date)
    if len(distinct_dates) == 10:
        break

top_events = df_plot.loc[distinct_dates].sort_index()

# Step 4: Plot base line with larger figure
plt.figure(figsize=(22, 9))  # Wider and taller
plt.plot(df_plot.index, df_plot['MoM_Change'], color='lightgray', linewidth=2, label='Month-over-Month Change')
plt.axhline(0, color='black', linestyle='--', linewidth=1)

# Step 5: Highlight segments approaching each top event
for date in top_events.index:
    idx = df_plot.index.get_loc(date)
    if idx > 0:
        prev_date = df_plot.index[idx - 1]
        segment = df_plot.loc[[prev_date, date]]
        color = 'green' if segment['MoM_Change'].iloc[1] > segment['MoM_Change'].iloc[0] else 'red'
        plt.plot(segment.index, segment['MoM_Change'], color=color, linewidth=3, zorder=4)

# Step 6: Scatter top events
colors = ['green' if row['MoM_Change'] > 0 else 'red' for _, row in top_events.iterrows()]
plt.scatter(top_events.index, top_events['MoM_Change'], color=colors, s=100, label='Top Events', edgecolor='black', zorder=5)

# Step 7: Annotate with closer offset and diagonal labels
for i, (date, row) in enumerate(top_events.iterrows()):
    value = row['MoM_Change']
    label = f"{date.strftime('%b %Y')}\n{value:+.2f}°C"

    y_offset = 0.015 if value > 0 else -0.025  # Closer offset

    plt.text(
        date,
        value + y_offset,
        label,
        ha='center',
        va='bottom' if value > 0 else 'top',
        fontsize=10,
        rotation=30,  # Diagonal label
        bbox=dict(boxstyle='round,pad=0.3', edgecolor='gray', facecolor='white')
    )

# Step 8: Final layout
plt.ylim(df_plot['MoM_Change'].min() - 0.05, df_plot['MoM_Change'].max() + 0.05)
plt.title('Top 10 Distinct Month-over-Month Temperature Change Events', fontsize=16, pad=20)
plt.xlabel('Date', fontsize=12)
plt.ylabel('Change in Anomaly (°C)', fontsize=12)
plt.legend()
plt.tight_layout()
plt.show()

# Summary printout
print("\nTop 10 Distinct Temperature Change Events:")
for date, row in top_events.iterrows():
    print(f"{date.strftime('%b %Y')}: {row['MoM_Change']:+.2f}°C")

